use oxc_ast::AstKind;
use oxc_span::GetSpan;

use crate::{doc::Doc, format::Format, Prettier};

impl<'a> Format<'a> for AstKind<'a> {
    fn format(&self, p: &mut Prettier<'a>) -> Doc<'a> {
        p.enter_node(*self);
        let leading = p.print_leading_comments(self.span());

        #[allow(clippy::match_same_arms)]
        let doc = match self {
            AstKind::Program(a) => a.format(p),
            AstKind::Directive(a) => a.format(p),
            AstKind::Hashbang(a) => a.format(p),
            AstKind::BlockStatement(a) => a.format(p),
            AstKind::BreakStatement(a) => a.format(p),
            AstKind::ContinueStatement(a) => a.format(p),
            AstKind::DebuggerStatement(a) => a.format(p),
            AstKind::DoWhileStatement(a) => a.format(p),
            AstKind::EmptyStatement(a) => a.format(p),
            AstKind::ExpressionStatement(a) => a.format(p),
            AstKind::ForInStatement(a) => a.format(p),
            AstKind::ForOfStatement(a) => a.format(p),
            AstKind::ForStatement(a) => a.format(p),
            AstKind::ForStatementInit(a) => a.format(p),
            AstKind::IfStatement(a) => a.format(p),
            AstKind::LabeledStatement(a) => a.format(p),
            AstKind::ReturnStatement(a) => a.format(p),
            AstKind::SwitchStatement(a) => a.format(p),
            AstKind::ThrowStatement(a) => a.format(p),
            AstKind::TryStatement(a) => a.format(p),
            AstKind::WhileStatement(a) => a.format(p),
            AstKind::WithStatement(a) => a.format(p),
            AstKind::SwitchCase(a) => a.format(p),
            AstKind::CatchClause(a) => a.format(p),
            AstKind::FinallyClause(a) => a.format(p),
            AstKind::VariableDeclaration(a) => a.format(p),
            AstKind::VariableDeclarator(a) => a.format(p),
            AstKind::UsingDeclaration(a) => a.format(p),
            AstKind::IdentifierName(a) => a.format(p),
            AstKind::IdentifierReference(a) => a.format(p),
            AstKind::BindingIdentifier(a) => a.format(p),
            AstKind::LabelIdentifier(a) => a.format(p),
            AstKind::PrivateIdentifier(a) => a.format(p),
            AstKind::NumberLiteral(a) => a.format(p),
            AstKind::StringLiteral(a) => a.format(p),
            AstKind::BooleanLiteral(a) => a.format(p),
            AstKind::NullLiteral(a) => a.format(p),
            AstKind::BigintLiteral(a) => a.format(p),
            AstKind::RegExpLiteral(a) => a.format(p),
            AstKind::TemplateLiteral(a) => a.format(p),
            AstKind::MetaProperty(a) => a.format(p),
            AstKind::Super(a) => a.format(p),
            AstKind::ArrayExpression(a) => a.format(p),
            AstKind::ArrowExpression(a) => a.format(p),
            AstKind::AssignmentExpression(a) => a.format(p),
            AstKind::AwaitExpression(a) => a.format(p),
            AstKind::BinaryExpression(a) => a.format(p),
            AstKind::CallExpression(a) => a.format(p),
            AstKind::ChainExpression(a) => a.format(p),
            AstKind::ConditionalExpression(a) => a.format(p),
            AstKind::LogicalExpression(a) => a.format(p),
            AstKind::MemberExpression(a) => a.format(p),
            AstKind::NewExpression(a) => a.format(p),
            AstKind::ObjectExpression(a) => a.format(p),
            AstKind::ParenthesizedExpression(a) => a.format(p),
            AstKind::SequenceExpression(a) => a.format(p),
            AstKind::TaggedTemplateExpression(a) => a.format(p),
            AstKind::ThisExpression(a) => a.format(p),
            AstKind::UnaryExpression(a) => a.format(p),
            AstKind::UpdateExpression(a) => a.format(p),
            AstKind::YieldExpression(a) => a.format(p),
            AstKind::ImportExpression(a) => a.format(p),
            AstKind::PrivateInExpression(a) => a.format(p),
            AstKind::ObjectProperty(a) => a.format(p),
            AstKind::PropertyKey(a) => a.format(p),
            AstKind::Argument(a) => a.format(p),
            AstKind::AssignmentTarget(a) => a.format(p),
            AstKind::SimpleAssignmentTarget(a) => a.format(p),
            AstKind::AssignmentTargetWithDefault(a) => a.format(p),
            AstKind::ArrayExpressionElement(a) => a.format(p),
            AstKind::ExpressionArrayElement(a) => a.format(p),
            AstKind::SpreadElement(a) => a.format(p),
            AstKind::RestElement(a) => a.format(p),
            AstKind::Function(a) => a.format(p),
            AstKind::FunctionBody(a) => a.format(p),
            AstKind::FormalParameters(a) => a.format(p),
            AstKind::FormalParameter(a) => a.format(p),
            AstKind::Class(a) => a.format(p),
            AstKind::ClassHeritage(a) => a.format(p),
            AstKind::StaticBlock(a) => a.format(p),
            AstKind::PropertyDefinition(a) => a.format(p),
            AstKind::MethodDefinition(a) => a.format(p),
            AstKind::ArrayPattern(a) => a.format(p),
            AstKind::ObjectPattern(a) => a.format(p),
            AstKind::AssignmentPattern(a) => a.format(p),
            AstKind::ModuleDeclaration(a) => a.format(p),
            AstKind::JSXElement(a) => a.format(p),
            AstKind::JSXFragment(a) => a.format(p),
            AstKind::JSXOpeningElement(a) => a.format(p),
            AstKind::JSXElementName(a) => a.format(p),
            AstKind::JSXExpressionContainer(a) => a.format(p),
            AstKind::JSXAttributeItem(a) => a.format(p),
            AstKind::JSXSpreadAttribute(a) => a.format(p),
            AstKind::JSXText(a) => a.format(p),
            AstKind::TSAnyKeyword(a) => a.format(p),
            AstKind::TSIntersectionType(a) => a.format(p),
            AstKind::TSLiteralType(a) => a.format(p),
            AstKind::TSNullKeyword(a) => a.format(p),
            AstKind::TSTypeLiteral(a) => a.format(p),
            AstKind::TSTypeReference(a) => a.format(p),
            AstKind::TSUnionType(a) => a.format(p),
            AstKind::TSVoidKeyword(a) => a.format(p),
            AstKind::TSIndexedAccessType(a) => a.format(p),
            AstKind::TSEnumDeclaration(a) => a.format(p),

            AstKind::TSImportEqualsDeclaration(a) => a.format(p),
            AstKind::TSInterfaceDeclaration(a) => a.format(p),
            AstKind::TSModuleDeclaration(a) => a.format(p),
            AstKind::TSTypeAliasDeclaration(a) => a.format(p),
            AstKind::TSTypeParameter(a) => a.format(p),
            AstKind::TSTypeParameterDeclaration(a) => a.format(p),
            AstKind::TSTypeParameterInstantiation(a) => a.format(p),
            _ => unreachable!(),
        };

        let doc = p.wrap_parens(doc, *self);
        let trailing = p.print_trailing_comments(self.span());
        let doc = p.print_comments(leading, doc, trailing);

        p.leave_node();

        doc
    }
}
